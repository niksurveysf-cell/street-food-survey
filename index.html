<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Street Food Survey</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#f4f7fb;
      --card:#ffffff;
      --accent:#1a73e8;
      --muted:#6b7280;
      --radius:12px;
      --shadow:0 8px 30px rgba(20,30,60,0.08);
    }
    html,body{height:100%}
    body{
      margin:0;
      font-family:"Roboto", Arial, Helvetica, sans-serif;
      background:linear-gradient(180deg,var(--bg),#fff);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:28px;
      display:flex;
      align-items:flex-start;
      justify-content:center;
    }

    .container{
      width:100%;
      max-width:820px;
      background:var(--card);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:28px;
      box-sizing:border-box;
      margin-bottom:28px;
    }

    header{
      display:flex;
      align-items:center;
      gap:16px;
      margin-bottom:12px;
    }
    .logo{
      width:56px;
      height:56px;
      border-radius:10px;
      background:linear-gradient(135deg,var(--accent),#6aa8ff);
      display:flex;
      align-items:center;
      justify-content:center;
      color:#fff;
      font-weight:700;
      font-size:20px;
      box-shadow:0 6px 18px rgba(26,115,232,0.18);
    }
    h2{ margin:0; font-size:20px; color:#0f1724; font-weight:600; }
    .subtitle{ color:var(--muted); font-size:0.95rem; margin-top:4px }

    .progress{
      height:8px;
      background:#eef5ff;
      border-radius:999px;
      overflow:hidden;
      margin-top:14px;
    }
    .progress > i{
      display:block;
      height:100%;
      background:linear-gradient(90deg,var(--accent),#6aa8ff);
      width:0%;
      transition:width .25s ease;
    }

    #status{ color:var(--muted); margin:10px 0 18px; font-size:0.95rem }

    .field-row{
      margin:14px 0;
      padding:12px;
      border-radius:10px;
      background:linear-gradient(180deg, rgba(250,250,252,0.6), rgba(250,250,252,0.4));
      border:1px solid #f0f3f8;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .field-row label{
      font-weight:600;
      color:#111827;
      font-size:0.98rem;
    }

    input[type="text"], input[type="number"], textarea, select{
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #e6e9ef;
      box-sizing:border-box;
      font-size:15px;
      color:#0f1724;
      background:#fff;
      outline:none;
      transition:box-shadow .12s ease, border-color .12s ease;
    }
    input:focus, textarea:focus, select:focus{
      border-color: rgba(26,115,232,0.9);
      box-shadow:0 6px 18px rgba(26,115,232,0.08);
    }
    textarea{ resize:vertical; min-height:72px; }

    .options{ display:flex; flex-direction:column; gap:8px; }
    .checkbox-item, .radio-item{
      display:flex; align-items:center; gap:10px; font-size:0.96rem; color:#111827;
    }
    .price-badge{
      margin-left:auto;
      background:#f1f5f9;
      color:#0f1724;
      padding:4px 8px;
      border-radius:999px;
      font-size:0.85rem;
      border:1px solid #e6eef8;
    }

    .controls{
      display:flex;
      gap:12px;
      align-items:center;
      margin-top:18px;
      flex-wrap:wrap;
    }
    button.primary{
      background:var(--accent);
      color:#fff;
      border:none;
      padding:10px 16px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      box-shadow:0 8px 20px rgba(26,115,232,0.12);
    }
    button.ghost{
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(26,115,232,0.12);
      padding:9px 14px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
    }
    .hint{ color:var(--muted); font-size:0.95rem; margin-top:10px }

    @media (max-width:520px){
      .container{ padding:18px }
      header{ gap:10px }
      .logo{ width:48px; height:48px; font-size:18px }
    }
  </style>
</head>
<body>
  <div class="container" role="main">
    <header>
      <div class="logo">SF</div>
      <div>
        <h2>Street Food Survey</h2>
        <div class="subtitle">Quick feedback — responses autosave as you interact</div>
      </div>
    </header>

    <div class="progress" aria-hidden="true"><i id="progressBar"></i></div>
    <div id="status" class="hint">Loading form…</div>

    <div id="formContainer" aria-live="polite"></div>

    <div class="controls">
      <button id="submitBtn" class="primary">Submit</button>
      <button id="clearBtn" class="ghost">Clear local draft</button>
      <div id="submitMsg" class="hint" style="margin-left:8px"></div>
    </div>

    <p class="hint">Tip: add your name as the first question so responses are easy to identify.</p>
  </div>

  <script>
    // ===== CONFIG =====
    const WEBAPP_URL = "https://script.google.com/macros/s/AKfycbyAv_jsMrG0VXxfroqJ5invTumj6C2VZoEsZA0irC7UmGuu_396yZfMDNUM1hMIFIIw_w/exec";
    const CONFIG_URL = WEBAPP_URL + "?config=1";

    // ===== session id persisted in localStorage =====
    let sessionId = localStorage.getItem("sf_session_id");
    if (!sessionId) {
      sessionId = Math.random().toString(36).slice(2, 10);
      localStorage.setItem("sf_session_id", sessionId);
    }

    // ===== autosave queue with debounce =====
    const pending = {};
    let debounceTimer = null;
    function scheduleSave(fieldName, fieldValue, itemCategory = "", price = "") {
      pending[fieldName] = { fieldValue, itemCategory, price };
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(flushPending, 350);
      updateProgressUI();
    }

    async function flushPending() {
      const entries = Object.entries(pending);
      if (!entries.length) return;
      for (const [fieldName, payload] of entries) {
        await sendToServer(fieldName, payload.fieldValue, payload.itemCategory, payload.price);
      }
      for (const k of entries.map(e => e[0])) delete pending[k];
    }

    async function sendToServer(fieldName, fieldValue, itemCategory = "", price = "") {
      try {
        const res = await fetch(WEBAPP_URL, {
          method: "POST",
          body: JSON.stringify({
            sessionId,
            fieldName,
            fieldValue,
            itemCategory,
            price
          })
        });
        try {
          const json = await res.json();
          if (json && json.status && json.status !== "ok") {
            console.warn("Server returned error:", json);
          }
        } catch (e) {
          // ignore parse errors
        }
      } catch (err) {
        console.error("Save error:", err);
      }
    }

    function saveField(fieldKey, value, category = "", price = "") {
      scheduleSave(fieldKey, value, category, price);
    }

    // ===== helpers to parse config options =====
    function parseOptions(optString) {
      if (!optString) return [];
      // support both comma and semicolon separators
      return optString.split(/[,;]+/).map(s => {
        const parts = s.split(":");
        return { label: parts[0].trim(), price: parts[1] ? parts[1].trim() : "" };
      }).filter(o => o.label);
    }

    // ===== build form from config rows =====
    function buildForm(config) {
      const container = document.getElementById("formContainer");
      container.innerHTML = "";
      if (!config || !config.length) {
        document.getElementById("status").textContent = "No form configuration found. Check the Config sheet.";
        return;
      }
      document.getElementById("status").textContent = "";

      config.forEach((q, idx) => {
        const type = (q.type || "").toLowerCase();
        const labelText = q.label || q.key || "question";
        const key = q.key || ("q_" + Math.random().toString(36).slice(2,6));
        const category = q.category || "";
        const priceDefault = q.price || "";

        const wrapper = document.createElement("div");
        wrapper.className = "field-row";

        const label = document.createElement("label");
        label.textContent = labelText;
        wrapper.appendChild(label);

        // helper to set data-key for later submit
        function setDataKey(el) {
          el.dataset.key = key;
          el.dataset.category = category || "";
        }

        if (type === "select" || type === "radio") {
          if (type === "select") {
            const sel = document.createElement("select");
            setDataKey(sel);
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "Select";
            sel.appendChild(placeholder);
            parseOptions(q.options).forEach(o => {
              const opt = document.createElement("option");
              opt.value = o.label;
              opt.textContent = o.label;
              sel.appendChild(opt);
            });
            sel.onchange = () => saveField(key, sel.value, category, priceDefault || "");
            wrapper.appendChild(sel);
          } else { // radio
            const box = document.createElement("div");
            box.className = "options";
            parseOptions(q.options).forEach(o => {
              const row = document.createElement("label");
              row.className = "radio-item";
              const r = document.createElement("input");
              r.type = "radio";
              r.name = key;
              r.value = o.label;
              r.dataset.key = key;
              r.onchange = () => saveField(key, r.value, category, o.price || "");
              const txt = document.createElement("span");
              txt.textContent = o.label;
              row.appendChild(r);
              row.appendChild(txt);
              if (o.price) {
                const badge = document.createElement("span");
                badge.className = "price-badge";
                badge.textContent = "₹" + o.price;
                row.appendChild(badge);
              }
              box.appendChild(row);
            });
            wrapper.appendChild(box);
          }
        } else if (type === "checkbox") {
          const box = document.createElement("div");
          box.className = "options";
          parseOptions(q.options).forEach(o => {
            const row = document.createElement("label");
            row.className = "checkbox-item";
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.value = o.label;
            cb.dataset.key = key + ":" + o.label;
            cb.onchange = () => saveField(key + ":" + o.label, cb.checked ? o.label : "", category, o.price || "");
            const txt = document.createElement("span");
            txt.textContent = o.label;
            row.appendChild(cb);
            row.appendChild(txt);
            if (o.price) {
              const badge = document.createElement("span");
              badge.className = "price-badge";
              badge.textContent = "₹" + o.price;
              row.appendChild(badge);
            }
            box.appendChild(row);
          });
          wrapper.appendChild(box);
        } else if (type === "textarea") {
          const ta = document.createElement("textarea");
          setDataKey(ta);
          ta.placeholder = q.placeholder || "";
          ta.onblur = () => saveField(key, ta.value, category, priceDefault);
          wrapper.appendChild(ta);
        } else { // text or default
          const inp = document.createElement("input");
          inp.type = q.type === "number" ? "number" : "text";
          setDataKey(inp);
          inp.placeholder = q.placeholder || "";
          inp.onblur = () => saveField(key, inp.value, category, priceDefault);
          wrapper.appendChild(inp);
        }

        container.appendChild(wrapper);
      });

      // update progress after building
      updateProgressUI();
    }

    // ===== load config from Apps Script doGet =====
    async function loadConfig() {
      try {
        const res = await fetch(CONFIG_URL, { cache: "no-store" });
        const json = await res.json();
        return json.config || [];
      } catch (e) {
        console.error("Failed to load config", e);
        document.getElementById("status").textContent = "Failed to load form configuration.";
        return [];
      }
    }

    // ===== progress UI =====
    function updateProgressUI() {
      const inputs = document.querySelectorAll("[data-key]");
      if (!inputs.length) {
        document.getElementById("progressBar").style.width = "0%";
        return;
      }
      let filled = 0;
      const seenKeys = new Set();
      inputs.forEach(el => {
        // for checkboxes/radios we count by name/key
        const k = el.dataset.key;
        if (!k) return;
        if (k.includes(":")) {
          // checkbox variant: count as filled if checked
          if (el.checked) seenKeys.add(k.split(":")[0] + ":" + k.split(":")[1]);
        } else {
          if (el.type === "radio") {
            // radios handled separately
            const radios = document.getElementsByName(k);
            for (const r of radios) if (r.checked) { seenKeys.add(k); break; }
          } else if (el.type === "checkbox") {
            if (el.checked) seenKeys.add(k);
          } else {
            if (el.value && el.value.toString().trim() !== "") seenKeys.add(k);
          }
        }
      });
      // approximate progress: unique keys filled / total unique keys
      const uniqueKeys = new Set();
      inputs.forEach(el => {
        const k = el.dataset.key;
        if (!k) return;
        uniqueKeys.add(k.includes(":") ? k.split(":")[0] : k);
      });
      const percent = uniqueKeys.size ? Math.round((seenKeys.size / uniqueKeys.size) * 100) : 0;
      document.getElementById("progressBar").style.width = percent + "%";
    }

    // ===== submit all answers as one row (optional final submit) =====
    async function submitAll() {
      const elements = document.querySelectorAll("[data-key]");
      const answers = {};
      // collect values: for checkboxes we collect comma list, for radios pick checked, for inputs take value
      const grouped = {};
      elements.forEach(el => {
        const rawKey = el.dataset.key;
        if (!rawKey) return;
        if (rawKey.includes(":")) {
          // checkbox variant key: "q1:Option"
          const parts = rawKey.split(":");
          const base = parts[0];
          const opt = parts[1];
          grouped[base] = grouped[base] || [];
          if (el.checked) grouped[base].push(opt);
        } else if (el.type === "radio") {
          // radios share name; skip here (we'll handle by name)
        } else if (el.type === "checkbox") {
          grouped[rawKey] = grouped[rawKey] || [];
          if (el.checked) grouped[rawKey].push(el.value);
        } else {
          grouped[rawKey] = el.value || "";
        }
      });

      // handle radio groups
      const radios = document.querySelectorAll("input[type=radio]");
      const radioNames = new Set();
      radios.forEach(r => radioNames.add(r.name));
      radioNames.forEach(name => {
        const sel = document.querySelector(`input[name="${name}"]:checked`);
        grouped[name] = sel ? sel.value : "";
      });

      // convert arrays to comma strings
      Object.keys(grouped).forEach(k => {
        if (Array.isArray(grouped[k])) answers[k] = grouped[k].join(", ");
        else answers[k] = grouped[k];
      });

      // final payload
      const payload = { sessionId, submitted: true, answers };
      try {
        const res = await fetch(WEBAPP_URL, { method: "POST", body: JSON.stringify(payload) });
        const text = await res.text();
        document.getElementById("submitMsg").textContent = "Thanks — your responses were submitted.";
        // optionally clear local draft
        // localStorage.removeItem("sf_session_id");
      } catch (err) {
        console.error("Submit failed", err);
        document.getElementById("submitMsg").textContent = "Submission failed — try again.";
      }
    }

    // ===== clear local draft =====
    function clearDraft() {
      localStorage.removeItem("sf_session_id");
      document.getElementById("submitMsg").textContent = "Local draft cleared. Reload the page to start a new session.";
    }

    // ===== initialize =====
    (async function init() {
      const config = await loadConfig();
      buildForm(config);

      // wire up buttons
      document.getElementById("submitBtn").addEventListener("click", submitAll);
      document.getElementById("clearBtn").addEventListener("click", clearDraft);

      // update progress periodically (in case autosave changes)
      setInterval(updateProgressUI, 700);
    })();
  </script>
</body>
</html>







